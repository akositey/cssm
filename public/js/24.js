(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[24],{

/***/ "./node_modules/signature_pad/dist/signature_pad.js":
/*!**********************************************************!*\
  !*** ./node_modules/signature_pad/dist/signature_pad.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*!\n * Signature Pad v3.0.0-beta.4 | https://github.com/szimek/signature_pad\n * (c) 2020 Szymon Nowak | Released under the MIT license\n */\n\nclass Point {\n    constructor(x, y, time) {\n        this.x = x;\n        this.y = y;\n        this.time = time || Date.now();\n    }\n    distanceTo(start) {\n        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y && this.time === other.time;\n    }\n    velocityFrom(start) {\n        return this.time !== start.time\n            ? this.distanceTo(start) / (this.time - start.time)\n            : 0;\n    }\n}\n\nclass Bezier {\n    constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n        this.startPoint = startPoint;\n        this.control2 = control2;\n        this.control1 = control1;\n        this.endPoint = endPoint;\n        this.startWidth = startWidth;\n        this.endWidth = endWidth;\n    }\n    static fromPoints(points, widths) {\n        const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n        const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n        return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n    }\n    static calculateControlPoints(s1, s2, s3) {\n        const dx1 = s1.x - s2.x;\n        const dy1 = s1.y - s2.y;\n        const dx2 = s2.x - s3.x;\n        const dy2 = s2.y - s3.y;\n        const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n        const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n        const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n        const dxm = m1.x - m2.x;\n        const dym = m1.y - m2.y;\n        const k = l2 / (l1 + l2);\n        const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n        const tx = s2.x - cm.x;\n        const ty = s2.y - cm.y;\n        return {\n            c1: new Point(m1.x + tx, m1.y + ty),\n            c2: new Point(m2.x + tx, m2.y + ty),\n        };\n    }\n    length() {\n        const steps = 10;\n        let length = 0;\n        let px;\n        let py;\n        for (let i = 0; i <= steps; i += 1) {\n            const t = i / steps;\n            const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n            const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n            if (i > 0) {\n                const xdiff = cx - px;\n                const ydiff = cy - py;\n                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n            }\n            px = cx;\n            py = cy;\n        }\n        return length;\n    }\n    point(t, start, c1, c2, end) {\n        return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\n            + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\n            + (3.0 * c2 * (1.0 - t) * t * t)\n            + (end * t * t * t);\n    }\n}\n\nfunction throttle(fn, wait = 250) {\n    let previous = 0;\n    let timeout = null;\n    let result;\n    let storedContext;\n    let storedArgs;\n    const later = () => {\n        previous = Date.now();\n        timeout = null;\n        result = fn.apply(storedContext, storedArgs);\n        if (!timeout) {\n            storedContext = null;\n            storedArgs = [];\n        }\n    };\n    return function wrapper(...args) {\n        const now = Date.now();\n        const remaining = wait - (now - previous);\n        storedContext = this;\n        storedArgs = args;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = fn.apply(storedContext, storedArgs);\n            if (!timeout) {\n                storedContext = null;\n                storedArgs = [];\n            }\n        }\n        else if (!timeout) {\n            timeout = window.setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\n\nclass SignaturePad {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.options = options;\n        this._handleMouseDown = (event) => {\n            if (event.which === 1) {\n                this._mouseButtonDown = true;\n                this._strokeBegin(event);\n            }\n        };\n        this._handleMouseMove = (event) => {\n            if (this._mouseButtonDown) {\n                this._strokeMoveUpdate(event);\n            }\n        };\n        this._handleMouseUp = (event) => {\n            if (event.which === 1 && this._mouseButtonDown) {\n                this._mouseButtonDown = false;\n                this._strokeEnd(event);\n            }\n        };\n        this._handleTouchStart = (event) => {\n            event.preventDefault();\n            if (event.targetTouches.length === 1) {\n                const touch = event.changedTouches[0];\n                this._strokeBegin(touch);\n            }\n        };\n        this._handleTouchMove = (event) => {\n            event.preventDefault();\n            const touch = event.targetTouches[0];\n            this._strokeMoveUpdate(touch);\n        };\n        this._handleTouchEnd = (event) => {\n            const wasCanvasTouched = event.target === this.canvas;\n            if (wasCanvasTouched) {\n                event.preventDefault();\n                const touch = event.changedTouches[0];\n                this._strokeEnd(touch);\n            }\n        };\n        this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n        this.minWidth = options.minWidth || 0.5;\n        this.maxWidth = options.maxWidth || 2.5;\n        this.throttle = ('throttle' in options ? options.throttle : 16);\n        this.minDistance = ('minDistance' in options\n            ? options.minDistance\n            : 5);\n        this.dotSize =\n            options.dotSize ||\n                function dotSize() {\n                    return (this.minWidth + this.maxWidth) / 2;\n                };\n        this.penColor = options.penColor || 'black';\n        this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n        this.onBegin = options.onBegin;\n        this.onEnd = options.onEnd;\n        this._strokeMoveUpdate = this.throttle\n            ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n            : SignaturePad.prototype._strokeUpdate;\n        this._ctx = canvas.getContext('2d');\n        this.clear();\n        this.on();\n    }\n    clear() {\n        const { _ctx: ctx, canvas } = this;\n        ctx.fillStyle = this.backgroundColor;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        this._data = [];\n        this._reset();\n        this._isEmpty = true;\n    }\n    fromDataURL(dataUrl, options = {}, callback) {\n        const image = new Image();\n        const ratio = options.ratio || window.devicePixelRatio || 1;\n        const width = options.width || this.canvas.width / ratio;\n        const height = options.height || this.canvas.height / ratio;\n        this._reset();\n        image.onload = () => {\n            this._ctx.drawImage(image, 0, 0, width, height);\n            if (callback) {\n                callback();\n            }\n        };\n        image.onerror = (error) => {\n            if (callback) {\n                callback(error);\n            }\n        };\n        image.src = dataUrl;\n        this._isEmpty = false;\n    }\n    toDataURL(type = 'image/png', encoderOptions) {\n        switch (type) {\n            case 'image/svg+xml':\n                return this._toSVG();\n            default:\n                return this.canvas.toDataURL(type, encoderOptions);\n        }\n    }\n    on() {\n        this.canvas.style.touchAction = 'none';\n        this.canvas.style.msTouchAction = 'none';\n        if (window.PointerEvent) {\n            this._handlePointerEvents();\n        }\n        else {\n            this._handleMouseEvents();\n            if ('ontouchstart' in window) {\n                this._handleTouchEvents();\n            }\n        }\n    }\n    off() {\n        this.canvas.style.touchAction = 'auto';\n        this.canvas.style.msTouchAction = 'auto';\n        this.canvas.removeEventListener('pointerdown', this._handleMouseDown);\n        this.canvas.removeEventListener('pointermove', this._handleMouseMove);\n        document.removeEventListener('pointerup', this._handleMouseUp);\n        this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n        this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n        document.removeEventListener('mouseup', this._handleMouseUp);\n        this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n        this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n        this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n    }\n    isEmpty() {\n        return this._isEmpty;\n    }\n    fromData(pointGroups) {\n        this.clear();\n        this._fromData(pointGroups, ({ color, curve }) => this._drawCurve({ color, curve }), ({ color, point }) => this._drawDot({ color, point }));\n        this._data = pointGroups;\n    }\n    toData() {\n        return this._data;\n    }\n    _strokeBegin(event) {\n        const newPointGroup = {\n            color: this.penColor,\n            points: [],\n        };\n        if (typeof this.onBegin === 'function') {\n            this.onBegin(event);\n        }\n        this._data.push(newPointGroup);\n        this._reset();\n        this._strokeUpdate(event);\n    }\n    _strokeUpdate(event) {\n        if (this._data.length === 0) {\n            this._strokeBegin(event);\n            return;\n        }\n        const x = event.clientX;\n        const y = event.clientY;\n        const point = this._createPoint(x, y);\n        const lastPointGroup = this._data[this._data.length - 1];\n        const lastPoints = lastPointGroup.points;\n        const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n        const isLastPointTooClose = lastPoint\n            ? point.distanceTo(lastPoint) <= this.minDistance\n            : false;\n        const color = lastPointGroup.color;\n        if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n            const curve = this._addPoint(point);\n            if (!lastPoint) {\n                this._drawDot({ color, point });\n            }\n            else if (curve) {\n                this._drawCurve({ color, curve });\n            }\n            lastPoints.push({\n                time: point.time,\n                x: point.x,\n                y: point.y,\n            });\n        }\n    }\n    _strokeEnd(event) {\n        this._strokeUpdate(event);\n        if (typeof this.onEnd === 'function') {\n            this.onEnd(event);\n        }\n    }\n    _handlePointerEvents() {\n        this._mouseButtonDown = false;\n        this.canvas.addEventListener('pointerdown', this._handleMouseDown);\n        this.canvas.addEventListener('pointermove', this._handleMouseMove);\n        document.addEventListener('pointerup', this._handleMouseUp);\n    }\n    _handleMouseEvents() {\n        this._mouseButtonDown = false;\n        this.canvas.addEventListener('mousedown', this._handleMouseDown);\n        this.canvas.addEventListener('mousemove', this._handleMouseMove);\n        document.addEventListener('mouseup', this._handleMouseUp);\n    }\n    _handleTouchEvents() {\n        this.canvas.addEventListener('touchstart', this._handleTouchStart);\n        this.canvas.addEventListener('touchmove', this._handleTouchMove);\n        this.canvas.addEventListener('touchend', this._handleTouchEnd);\n    }\n    _reset() {\n        this._lastPoints = [];\n        this._lastVelocity = 0;\n        this._lastWidth = (this.minWidth + this.maxWidth) / 2;\n        this._ctx.fillStyle = this.penColor;\n    }\n    _createPoint(x, y) {\n        const rect = this.canvas.getBoundingClientRect();\n        return new Point(x - rect.left, y - rect.top, new Date().getTime());\n    }\n    _addPoint(point) {\n        const { _lastPoints } = this;\n        _lastPoints.push(point);\n        if (_lastPoints.length > 2) {\n            if (_lastPoints.length === 3) {\n                _lastPoints.unshift(_lastPoints[0]);\n            }\n            const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);\n            const curve = Bezier.fromPoints(_lastPoints, widths);\n            _lastPoints.shift();\n            return curve;\n        }\n        return null;\n    }\n    _calculateCurveWidths(startPoint, endPoint) {\n        const velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n            (1 - this.velocityFilterWeight) * this._lastVelocity;\n        const newWidth = this._strokeWidth(velocity);\n        const widths = {\n            end: newWidth,\n            start: this._lastWidth,\n        };\n        this._lastVelocity = velocity;\n        this._lastWidth = newWidth;\n        return widths;\n    }\n    _strokeWidth(velocity) {\n        return Math.max(this.maxWidth / (velocity + 1), this.minWidth);\n    }\n    _drawCurveSegment(x, y, width) {\n        const ctx = this._ctx;\n        ctx.moveTo(x, y);\n        ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n        this._isEmpty = false;\n    }\n    _drawCurve({ color, curve }) {\n        const ctx = this._ctx;\n        const widthDelta = curve.endWidth - curve.startWidth;\n        const drawSteps = Math.floor(curve.length()) * 2;\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        for (let i = 0; i < drawSteps; i += 1) {\n            const t = i / drawSteps;\n            const tt = t * t;\n            const ttt = tt * t;\n            const u = 1 - t;\n            const uu = u * u;\n            const uuu = uu * u;\n            let x = uuu * curve.startPoint.x;\n            x += 3 * uu * t * curve.control1.x;\n            x += 3 * u * tt * curve.control2.x;\n            x += ttt * curve.endPoint.x;\n            let y = uuu * curve.startPoint.y;\n            y += 3 * uu * t * curve.control1.y;\n            y += 3 * u * tt * curve.control2.y;\n            y += ttt * curve.endPoint.y;\n            const width = Math.min(curve.startWidth + ttt * widthDelta, this.maxWidth);\n            this._drawCurveSegment(x, y, width);\n        }\n        ctx.closePath();\n        ctx.fill();\n    }\n    _drawDot({ color, point, }) {\n        const ctx = this._ctx;\n        const width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\n        ctx.beginPath();\n        this._drawCurveSegment(point.x, point.y, width);\n        ctx.closePath();\n        ctx.fillStyle = color;\n        ctx.fill();\n    }\n    _fromData(pointGroups, drawCurve, drawDot) {\n        for (const group of pointGroups) {\n            const { color, points } = group;\n            if (points.length > 1) {\n                for (let j = 0; j < points.length; j += 1) {\n                    const basicPoint = points[j];\n                    const point = new Point(basicPoint.x, basicPoint.y, basicPoint.time);\n                    this.penColor = color;\n                    if (j === 0) {\n                        this._reset();\n                    }\n                    const curve = this._addPoint(point);\n                    if (curve) {\n                        drawCurve({ color, curve });\n                    }\n                }\n            }\n            else {\n                this._reset();\n                drawDot({\n                    color,\n                    point: points[0],\n                });\n            }\n        }\n    }\n    _toSVG() {\n        const pointGroups = this._data;\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const minX = 0;\n        const minY = 0;\n        const maxX = this.canvas.width / ratio;\n        const maxY = this.canvas.height / ratio;\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.setAttribute('width', this.canvas.width.toString());\n        svg.setAttribute('height', this.canvas.height.toString());\n        this._fromData(pointGroups, ({ color, curve }) => {\n            const path = document.createElement('path');\n            if (!isNaN(curve.control1.x) &&\n                !isNaN(curve.control1.y) &&\n                !isNaN(curve.control2.x) &&\n                !isNaN(curve.control2.y)) {\n                const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} ` +\n                    `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n                    `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n                    `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n                path.setAttribute('d', attr);\n                path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n                path.setAttribute('stroke', color);\n                path.setAttribute('fill', 'none');\n                path.setAttribute('stroke-linecap', 'round');\n                svg.appendChild(path);\n            }\n        }, ({ color, point }) => {\n            const circle = document.createElement('circle');\n            const dotSize = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\n            circle.setAttribute('r', dotSize.toString());\n            circle.setAttribute('cx', point.x.toString());\n            circle.setAttribute('cy', point.y.toString());\n            circle.setAttribute('fill', color);\n            svg.appendChild(circle);\n        });\n        const prefix = 'data:image/svg+xml;base64,';\n        const header = '<svg' +\n            ' xmlns=\"http://www.w3.org/2000/svg\"' +\n            ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"' +\n            ` viewBox=\"${minX} ${minY} ${maxX} ${maxY}\"` +\n            ` width=\"${maxX}\"` +\n            ` height=\"${maxY}\"` +\n            '>';\n        let body = svg.innerHTML;\n        if (body === undefined) {\n            const dummy = document.createElement('dummy');\n            const nodes = svg.childNodes;\n            dummy.innerHTML = '';\n            for (let i = 0; i < nodes.length; i += 1) {\n                dummy.appendChild(nodes[i].cloneNode(true));\n            }\n            body = dummy.innerHTML;\n        }\n        const footer = '</svg>';\n        const data = header + body + footer;\n        return prefix + btoa(data);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SignaturePad);\n//# sourceMappingURL=signature_pad.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2lnbmF0dXJlX3BhZC9kaXN0L3NpZ25hdHVyZV9wYWQuanM/OTBlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxzQkFBc0IsZUFBZSxLQUFLLGVBQWUsb0JBQW9CLGVBQWU7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhCQUE4QixHQUFHLDhCQUE4QjtBQUNqRyx5QkFBeUIsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQ3BGLHVCQUF1Qiw0QkFBNEIsR0FBRyw0QkFBNEI7QUFDbEYsdUJBQXVCLDRCQUE0QixHQUFHLDRCQUE0QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUN0RCx1QkFBdUIsS0FBSztBQUM1Qix3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSwyRUFBWSxFQUFDO0FBQzVCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3NpZ25hdHVyZV9wYWQvZGlzdC9zaWduYXR1cmVfcGFkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTaWduYXR1cmUgUGFkIHYzLjAuMC1iZXRhLjQgfCBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL3NpZ25hdHVyZV9wYWRcbiAqIChjKSAyMDIwIFN6eW1vbiBOb3dhayB8IFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cbmNsYXNzIFBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB0aW1lKSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWUgfHwgRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgZGlzdGFuY2VUbyhzdGFydCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCAtIHN0YXJ0LngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gc3RhcnQueSwgMikpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnkgJiYgdGhpcy50aW1lID09PSBvdGhlci50aW1lO1xuICAgIH1cbiAgICB2ZWxvY2l0eUZyb20oc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZSAhPT0gc3RhcnQudGltZVxuICAgICAgICAgICAgPyB0aGlzLmRpc3RhbmNlVG8oc3RhcnQpIC8gKHRoaXMudGltZSAtIHN0YXJ0LnRpbWUpXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxufVxuXG5jbGFzcyBCZXppZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0UG9pbnQsIGNvbnRyb2wyLCBjb250cm9sMSwgZW5kUG9pbnQsIHN0YXJ0V2lkdGgsIGVuZFdpZHRoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gICAgICAgIHRoaXMuY29udHJvbDIgPSBjb250cm9sMjtcbiAgICAgICAgdGhpcy5jb250cm9sMSA9IGNvbnRyb2wxO1xuICAgICAgICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XG4gICAgICAgIHRoaXMuc3RhcnRXaWR0aCA9IHN0YXJ0V2lkdGg7XG4gICAgICAgIHRoaXMuZW5kV2lkdGggPSBlbmRXaWR0aDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qb2ludHMocG9pbnRzLCB3aWR0aHMpIHtcbiAgICAgICAgY29uc3QgYzIgPSB0aGlzLmNhbGN1bGF0ZUNvbnRyb2xQb2ludHMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSkuYzI7XG4gICAgICAgIGNvbnN0IGMzID0gdGhpcy5jYWxjdWxhdGVDb250cm9sUG9pbnRzKHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pLmMxO1xuICAgICAgICByZXR1cm4gbmV3IEJlemllcihwb2ludHNbMV0sIGMyLCBjMywgcG9pbnRzWzJdLCB3aWR0aHMuc3RhcnQsIHdpZHRocy5lbmQpO1xuICAgIH1cbiAgICBzdGF0aWMgY2FsY3VsYXRlQ29udHJvbFBvaW50cyhzMSwgczIsIHMzKSB7XG4gICAgICAgIGNvbnN0IGR4MSA9IHMxLnggLSBzMi54O1xuICAgICAgICBjb25zdCBkeTEgPSBzMS55IC0gczIueTtcbiAgICAgICAgY29uc3QgZHgyID0gczIueCAtIHMzLng7XG4gICAgICAgIGNvbnN0IGR5MiA9IHMyLnkgLSBzMy55O1xuICAgICAgICBjb25zdCBtMSA9IHsgeDogKHMxLnggKyBzMi54KSAvIDIuMCwgeTogKHMxLnkgKyBzMi55KSAvIDIuMCB9O1xuICAgICAgICBjb25zdCBtMiA9IHsgeDogKHMyLnggKyBzMy54KSAvIDIuMCwgeTogKHMyLnkgKyBzMy55KSAvIDIuMCB9O1xuICAgICAgICBjb25zdCBsMSA9IE1hdGguc3FydChkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICAgICAgICBjb25zdCBsMiA9IE1hdGguc3FydChkeDIgKiBkeDIgKyBkeTIgKiBkeTIpO1xuICAgICAgICBjb25zdCBkeG0gPSBtMS54IC0gbTIueDtcbiAgICAgICAgY29uc3QgZHltID0gbTEueSAtIG0yLnk7XG4gICAgICAgIGNvbnN0IGsgPSBsMiAvIChsMSArIGwyKTtcbiAgICAgICAgY29uc3QgY20gPSB7IHg6IG0yLnggKyBkeG0gKiBrLCB5OiBtMi55ICsgZHltICogayB9O1xuICAgICAgICBjb25zdCB0eCA9IHMyLnggLSBjbS54O1xuICAgICAgICBjb25zdCB0eSA9IHMyLnkgLSBjbS55O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzE6IG5ldyBQb2ludChtMS54ICsgdHgsIG0xLnkgKyB0eSksXG4gICAgICAgICAgICBjMjogbmV3IFBvaW50KG0yLnggKyB0eCwgbTIueSArIHR5KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCBzdGVwcyA9IDEwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IHB4O1xuICAgICAgICBsZXQgcHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHN0ZXBzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBpIC8gc3RlcHM7XG4gICAgICAgICAgICBjb25zdCBjeCA9IHRoaXMucG9pbnQodCwgdGhpcy5zdGFydFBvaW50LngsIHRoaXMuY29udHJvbDEueCwgdGhpcy5jb250cm9sMi54LCB0aGlzLmVuZFBvaW50LngpO1xuICAgICAgICAgICAgY29uc3QgY3kgPSB0aGlzLnBvaW50KHQsIHRoaXMuc3RhcnRQb2ludC55LCB0aGlzLmNvbnRyb2wxLnksIHRoaXMuY29udHJvbDIueSwgdGhpcy5lbmRQb2ludC55KTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHhkaWZmID0gY3ggLSBweDtcbiAgICAgICAgICAgICAgICBjb25zdCB5ZGlmZiA9IGN5IC0gcHk7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IE1hdGguc3FydCh4ZGlmZiAqIHhkaWZmICsgeWRpZmYgKiB5ZGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBweCA9IGN4O1xuICAgICAgICAgICAgcHkgPSBjeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgICBwb2ludCh0LCBzdGFydCwgYzEsIGMyLCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIChzdGFydCAqICgxLjAgLSB0KSAqICgxLjAgLSB0KSAqICgxLjAgLSB0KSlcbiAgICAgICAgICAgICsgKDMuMCAqIGMxICogKDEuMCAtIHQpICogKDEuMCAtIHQpICogdClcbiAgICAgICAgICAgICsgKDMuMCAqIGMyICogKDEuMCAtIHQpICogdCAqIHQpXG4gICAgICAgICAgICArIChlbmQgKiB0ICogdCAqIHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHdhaXQgPSAyNTApIHtcbiAgICBsZXQgcHJldmlvdXMgPSAwO1xuICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBzdG9yZWRDb250ZXh0O1xuICAgIGxldCBzdG9yZWRBcmdzO1xuICAgIGNvbnN0IGxhdGVyID0gKCkgPT4ge1xuICAgICAgICBwcmV2aW91cyA9IERhdGUubm93KCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICByZXN1bHQgPSBmbi5hcHBseShzdG9yZWRDb250ZXh0LCBzdG9yZWRBcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgICAgICBzdG9yZWRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHN0b3JlZEFyZ3MgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgc3RvcmVkQ29udGV4dCA9IHRoaXM7XG4gICAgICAgIHN0b3JlZEFyZ3MgPSBhcmdzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KHN0b3JlZENvbnRleHQsIHN0b3JlZEFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgc3RvcmVkQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RvcmVkQXJncyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuXG5jbGFzcyBTaWduYXR1cmVQYWQge1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC53aGljaCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlQnV0dG9uRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Ryb2tlQmVnaW4oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZUJ1dHRvbkRvd24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VNb3ZlVXBkYXRlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VVcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAxICYmIHRoaXMuX21vdXNlQnV0dG9uRG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlQnV0dG9uRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZUVuZChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZUJlZ2luKHRvdWNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGFuZGxlVG91Y2hNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50YXJnZXRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlTW92ZVVwZGF0ZSh0b3VjaCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hhbmRsZVRvdWNoRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3YXNDYW52YXNUb3VjaGVkID0gZXZlbnQudGFyZ2V0ID09PSB0aGlzLmNhbnZhcztcbiAgICAgICAgICAgIGlmICh3YXNDYW52YXNUb3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZUVuZCh0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmVsb2NpdHlGaWx0ZXJXZWlnaHQgPSBvcHRpb25zLnZlbG9jaXR5RmlsdGVyV2VpZ2h0IHx8IDAuNztcbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IG9wdGlvbnMubWluV2lkdGggfHwgMC41O1xuICAgICAgICB0aGlzLm1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aCB8fCAyLjU7XG4gICAgICAgIHRoaXMudGhyb3R0bGUgPSAoJ3Rocm90dGxlJyBpbiBvcHRpb25zID8gb3B0aW9ucy50aHJvdHRsZSA6IDE2KTtcbiAgICAgICAgdGhpcy5taW5EaXN0YW5jZSA9ICgnbWluRGlzdGFuY2UnIGluIG9wdGlvbnNcbiAgICAgICAgICAgID8gb3B0aW9ucy5taW5EaXN0YW5jZVxuICAgICAgICAgICAgOiA1KTtcbiAgICAgICAgdGhpcy5kb3RTaXplID1cbiAgICAgICAgICAgIG9wdGlvbnMuZG90U2l6ZSB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvdFNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5taW5XaWR0aCArIHRoaXMubWF4V2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLnBlbkNvbG9yID0gb3B0aW9ucy5wZW5Db2xvciB8fCAnYmxhY2snO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yIHx8ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgdGhpcy5vbkJlZ2luID0gb3B0aW9ucy5vbkJlZ2luO1xuICAgICAgICB0aGlzLm9uRW5kID0gb3B0aW9ucy5vbkVuZDtcbiAgICAgICAgdGhpcy5fc3Ryb2tlTW92ZVVwZGF0ZSA9IHRoaXMudGhyb3R0bGVcbiAgICAgICAgICAgID8gdGhyb3R0bGUoU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlVXBkYXRlLCB0aGlzLnRocm90dGxlKVxuICAgICAgICAgICAgOiBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9zdHJva2VVcGRhdGU7XG4gICAgICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMub24oKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IHsgX2N0eDogY3R4LCBjYW52YXMgfSA9IHRoaXM7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICB0aGlzLl9pc0VtcHR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgZnJvbURhdGFVUkwoZGF0YVVybCwgb3B0aW9ucyA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCByYXRpbyA9IG9wdGlvbnMucmF0aW8gfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IHRoaXMuY2FudmFzLndpZHRoIC8gcmF0aW87XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuY2FudmFzLmhlaWdodCAvIHJhdGlvO1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gZGF0YVVybDtcbiAgICAgICAgdGhpcy5faXNFbXB0eSA9IGZhbHNlO1xuICAgIH1cbiAgICB0b0RhdGFVUkwodHlwZSA9ICdpbWFnZS9wbmcnLCBlbmNvZGVyT3B0aW9ucykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ltYWdlL3N2Zyt4bWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b1NWRygpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKHR5cGUsIGVuY29kZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gICAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2ZmKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9ICdhdXRvJztcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdhdXRvJztcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLl9oYW5kbGVNb3VzZURvd24pO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuX2hhbmRsZU1vdXNlVXApO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVNb3VzZURvd24pO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VVcCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVUb3VjaEVuZCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0VtcHR5O1xuICAgIH1cbiAgICBmcm9tRGF0YShwb2ludEdyb3Vwcykge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2Zyb21EYXRhKHBvaW50R3JvdXBzLCAoeyBjb2xvciwgY3VydmUgfSkgPT4gdGhpcy5fZHJhd0N1cnZlKHsgY29sb3IsIGN1cnZlIH0pLCAoeyBjb2xvciwgcG9pbnQgfSkgPT4gdGhpcy5fZHJhd0RvdCh7IGNvbG9yLCBwb2ludCB9KSk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBwb2ludEdyb3VwcztcbiAgICB9XG4gICAgdG9EYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG4gICAgX3N0cm9rZUJlZ2luKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG5ld1BvaW50R3JvdXAgPSB7XG4gICAgICAgICAgICBjb2xvcjogdGhpcy5wZW5Db2xvcixcbiAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkJlZ2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uQmVnaW4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChuZXdQb2ludEdyb3VwKTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgdGhpcy5fc3Ryb2tlVXBkYXRlKGV2ZW50KTtcbiAgICB9XG4gICAgX3N0cm9rZVVwZGF0ZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZUJlZ2luKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fY3JlYXRlUG9pbnQoeCwgeSk7XG4gICAgICAgIGNvbnN0IGxhc3RQb2ludEdyb3VwID0gdGhpcy5fZGF0YVt0aGlzLl9kYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBsYXN0UG9pbnRzID0gbGFzdFBvaW50R3JvdXAucG9pbnRzO1xuICAgICAgICBjb25zdCBsYXN0UG9pbnQgPSBsYXN0UG9pbnRzLmxlbmd0aCA+IDAgJiYgbGFzdFBvaW50c1tsYXN0UG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBpc0xhc3RQb2ludFRvb0Nsb3NlID0gbGFzdFBvaW50XG4gICAgICAgICAgICA/IHBvaW50LmRpc3RhbmNlVG8obGFzdFBvaW50KSA8PSB0aGlzLm1pbkRpc3RhbmNlXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjb2xvciA9IGxhc3RQb2ludEdyb3VwLmNvbG9yO1xuICAgICAgICBpZiAoIWxhc3RQb2ludCB8fCAhKGxhc3RQb2ludCAmJiBpc0xhc3RQb2ludFRvb0Nsb3NlKSkge1xuICAgICAgICAgICAgY29uc3QgY3VydmUgPSB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gICAgICAgICAgICBpZiAoIWxhc3RQb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdEb3QoeyBjb2xvciwgcG9pbnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJ2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDdXJ2ZSh7IGNvbG9yLCBjdXJ2ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RQb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGltZTogcG9pbnQudGltZSxcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICAgICAgICAgIHk6IHBvaW50LnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3Ryb2tlRW5kKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3N0cm9rZVVwZGF0ZShldmVudCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbkVuZChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2hhbmRsZVBvaW50ZXJFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuX21vdXNlQnV0dG9uRG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX2hhbmRsZU1vdXNlRG93bik7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5faGFuZGxlTW91c2VVcCk7XG4gICAgfVxuICAgIF9oYW5kbGVNb3VzZUV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5fbW91c2VCdXR0b25Eb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZU1vdXNlRG93bik7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZVVwKTtcbiAgICB9XG4gICAgX2hhbmRsZVRvdWNoRXZlbnRzKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlVG91Y2hTdGFydCk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVRvdWNoTW92ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlVG91Y2hFbmQpO1xuICAgIH1cbiAgICBfcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX2xhc3RQb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5fbGFzdFZlbG9jaXR5ID0gMDtcbiAgICAgICAgdGhpcy5fbGFzdFdpZHRoID0gKHRoaXMubWluV2lkdGggKyB0aGlzLm1heFdpZHRoKSAvIDI7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSB0aGlzLnBlbkNvbG9yO1xuICAgIH1cbiAgICBfY3JlYXRlUG9pbnQoeCwgeSkge1xuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCAtIHJlY3QubGVmdCwgeSAtIHJlY3QudG9wLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIF9hZGRQb2ludChwb2ludCkge1xuICAgICAgICBjb25zdCB7IF9sYXN0UG9pbnRzIH0gPSB0aGlzO1xuICAgICAgICBfbGFzdFBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgaWYgKF9sYXN0UG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGlmIChfbGFzdFBvaW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBfbGFzdFBvaW50cy51bnNoaWZ0KF9sYXN0UG9pbnRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdpZHRocyA9IHRoaXMuX2NhbGN1bGF0ZUN1cnZlV2lkdGhzKF9sYXN0UG9pbnRzWzFdLCBfbGFzdFBvaW50c1syXSk7XG4gICAgICAgICAgICBjb25zdCBjdXJ2ZSA9IEJlemllci5mcm9tUG9pbnRzKF9sYXN0UG9pbnRzLCB3aWR0aHMpO1xuICAgICAgICAgICAgX2xhc3RQb2ludHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2NhbGN1bGF0ZUN1cnZlV2lkdGhzKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XG4gICAgICAgIGNvbnN0IHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCAqIGVuZFBvaW50LnZlbG9jaXR5RnJvbShzdGFydFBvaW50KSArXG4gICAgICAgICAgICAoMSAtIHRoaXMudmVsb2NpdHlGaWx0ZXJXZWlnaHQpICogdGhpcy5fbGFzdFZlbG9jaXR5O1xuICAgICAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMuX3N0cm9rZVdpZHRoKHZlbG9jaXR5KTtcbiAgICAgICAgY29uc3Qgd2lkdGhzID0ge1xuICAgICAgICAgICAgZW5kOiBuZXdXaWR0aCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLl9sYXN0V2lkdGgsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xhc3RWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgICAgICB0aGlzLl9sYXN0V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgcmV0dXJuIHdpZHRocztcbiAgICB9XG4gICAgX3N0cm9rZVdpZHRoKHZlbG9jaXR5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm1heFdpZHRoIC8gKHZlbG9jaXR5ICsgMSksIHRoaXMubWluV2lkdGgpO1xuICAgIH1cbiAgICBfZHJhd0N1cnZlU2VnbWVudCh4LCB5LCB3aWR0aCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgd2lkdGgsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2lzRW1wdHkgPSBmYWxzZTtcbiAgICB9XG4gICAgX2RyYXdDdXJ2ZSh7IGNvbG9yLCBjdXJ2ZSB9KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY29uc3Qgd2lkdGhEZWx0YSA9IGN1cnZlLmVuZFdpZHRoIC0gY3VydmUuc3RhcnRXaWR0aDtcbiAgICAgICAgY29uc3QgZHJhd1N0ZXBzID0gTWF0aC5mbG9vcihjdXJ2ZS5sZW5ndGgoKSkgKiAyO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmF3U3RlcHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgdCA9IGkgLyBkcmF3U3RlcHM7XG4gICAgICAgICAgICBjb25zdCB0dCA9IHQgKiB0O1xuICAgICAgICAgICAgY29uc3QgdHR0ID0gdHQgKiB0O1xuICAgICAgICAgICAgY29uc3QgdSA9IDEgLSB0O1xuICAgICAgICAgICAgY29uc3QgdXUgPSB1ICogdTtcbiAgICAgICAgICAgIGNvbnN0IHV1dSA9IHV1ICogdTtcbiAgICAgICAgICAgIGxldCB4ID0gdXV1ICogY3VydmUuc3RhcnRQb2ludC54O1xuICAgICAgICAgICAgeCArPSAzICogdXUgKiB0ICogY3VydmUuY29udHJvbDEueDtcbiAgICAgICAgICAgIHggKz0gMyAqIHUgKiB0dCAqIGN1cnZlLmNvbnRyb2wyLng7XG4gICAgICAgICAgICB4ICs9IHR0dCAqIGN1cnZlLmVuZFBvaW50Lng7XG4gICAgICAgICAgICBsZXQgeSA9IHV1dSAqIGN1cnZlLnN0YXJ0UG9pbnQueTtcbiAgICAgICAgICAgIHkgKz0gMyAqIHV1ICogdCAqIGN1cnZlLmNvbnRyb2wxLnk7XG4gICAgICAgICAgICB5ICs9IDMgKiB1ICogdHQgKiBjdXJ2ZS5jb250cm9sMi55O1xuICAgICAgICAgICAgeSArPSB0dHQgKiBjdXJ2ZS5lbmRQb2ludC55O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihjdXJ2ZS5zdGFydFdpZHRoICsgdHR0ICogd2lkdGhEZWx0YSwgdGhpcy5tYXhXaWR0aCk7XG4gICAgICAgICAgICB0aGlzLl9kcmF3Q3VydmVTZWdtZW50KHgsIHksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIF9kcmF3RG90KHsgY29sb3IsIHBvaW50LCB9KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0eXBlb2YgdGhpcy5kb3RTaXplID09PSAnZnVuY3Rpb24nID8gdGhpcy5kb3RTaXplKCkgOiB0aGlzLmRvdFNpemU7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fZHJhd0N1cnZlU2VnbWVudChwb2ludC54LCBwb2ludC55LCB3aWR0aCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBfZnJvbURhdGEocG9pbnRHcm91cHMsIGRyYXdDdXJ2ZSwgZHJhd0RvdCkge1xuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHBvaW50R3JvdXBzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbG9yLCBwb2ludHMgfSA9IGdyb3VwO1xuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzaWNQb2ludCA9IHBvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoYmFzaWNQb2ludC54LCBiYXNpY1BvaW50LnksIGJhc2ljUG9pbnQudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VydmUgPSB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0N1cnZlKHsgY29sb3IsIGN1cnZlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgICAgICAgICBkcmF3RG90KHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3RvU1ZHKCkge1xuICAgICAgICBjb25zdCBwb2ludEdyb3VwcyA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG4gICAgICAgIGNvbnN0IG1pblggPSAwO1xuICAgICAgICBjb25zdCBtaW5ZID0gMDtcbiAgICAgICAgY29uc3QgbWF4WCA9IHRoaXMuY2FudmFzLndpZHRoIC8gcmF0aW87XG4gICAgICAgIGNvbnN0IG1heFkgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyByYXRpbztcbiAgICAgICAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmNhbnZhcy53aWR0aC50b1N0cmluZygpKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5jYW52YXMuaGVpZ2h0LnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLl9mcm9tRGF0YShwb2ludEdyb3VwcywgKHsgY29sb3IsIGN1cnZlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwYXRoJyk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGN1cnZlLmNvbnRyb2wxLngpICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKGN1cnZlLmNvbnRyb2wxLnkpICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKGN1cnZlLmNvbnRyb2wyLngpICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKGN1cnZlLmNvbnRyb2wyLnkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGBNICR7Y3VydmUuc3RhcnRQb2ludC54LnRvRml4ZWQoMyl9LCR7Y3VydmUuc3RhcnRQb2ludC55LnRvRml4ZWQoMyl9IGAgK1xuICAgICAgICAgICAgICAgICAgICBgQyAke2N1cnZlLmNvbnRyb2wxLngudG9GaXhlZCgzKX0sJHtjdXJ2ZS5jb250cm9sMS55LnRvRml4ZWQoMyl9IGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHtjdXJ2ZS5jb250cm9sMi54LnRvRml4ZWQoMyl9LCR7Y3VydmUuY29udHJvbDIueS50b0ZpeGVkKDMpfSBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7Y3VydmUuZW5kUG9pbnQueC50b0ZpeGVkKDMpfSwke2N1cnZlLmVuZFBvaW50LnkudG9GaXhlZCgzKX1gO1xuICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgYXR0cik7XG4gICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIChjdXJ2ZS5lbmRXaWR0aCAqIDIuMjUpLnRvRml4ZWQoMykpO1xuICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpO1xuICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgKHsgY29sb3IsIHBvaW50IH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NpcmNsZScpO1xuICAgICAgICAgICAgY29uc3QgZG90U2l6ZSA9IHR5cGVvZiB0aGlzLmRvdFNpemUgPT09ICdmdW5jdGlvbicgPyB0aGlzLmRvdFNpemUoKSA6IHRoaXMuZG90U2l6ZTtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ3InLCBkb3RTaXplLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3gnLCBwb2ludC54LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3knLCBwb2ludC55LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGNvbG9yKTtcbiAgICAgICAgICAgIHN2Zy5hcHBlbmRDaGlsZChjaXJjbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJztcbiAgICAgICAgY29uc3QgaGVhZGVyID0gJzxzdmcnICtcbiAgICAgICAgICAgICcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJyArXG4gICAgICAgICAgICAnIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiJyArXG4gICAgICAgICAgICBgIHZpZXdCb3g9XCIke21pblh9ICR7bWluWX0gJHttYXhYfSAke21heFl9XCJgICtcbiAgICAgICAgICAgIGAgd2lkdGg9XCIke21heFh9XCJgICtcbiAgICAgICAgICAgIGAgaGVpZ2h0PVwiJHttYXhZfVwiYCArXG4gICAgICAgICAgICAnPic7XG4gICAgICAgIGxldCBib2R5ID0gc3ZnLmlubmVySFRNTDtcbiAgICAgICAgaWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkdW1teScpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBzdmcuY2hpbGROb2RlcztcbiAgICAgICAgICAgIGR1bW15LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGR1bW15LmFwcGVuZENoaWxkKG5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5ID0gZHVtbXkuaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvb3RlciA9ICc8L3N2Zz4nO1xuICAgICAgICBjb25zdCBkYXRhID0gaGVhZGVyICsgYm9keSArIGZvb3RlcjtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIGJ0b2EoZGF0YSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTaWduYXR1cmVQYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmVfcGFkLmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/signature_pad/dist/signature_pad.js\n");

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n        injectStyles.call(\n          this,\n          (options.functional ? this.parent : this).$root.$options.shadowRoot\n        )\n      }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzPzI4NzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n");

/***/ })

}]);